1. `strings.Builder`. Он позволяет конкатенировать строки
    избегая неэффективного копирования и управляет памятью более эффективно
    чем это делает оператор '+'

2. Интерфейсы это набор соглашений о том, какие действия и какой функционал
    должен быть у обьекта. Они создают контракты между различными типами, определяя набор 
    методов, которые они должны реализовать. Использование интерфейсов 
    позволяет объектам оперировать абстрациями, не привязываясь к конкретным реализациям
    других объектов. Обеспечивают гибкость и позволяют группировать различные
    поведения. Применяются для достижения полиморфизма и абстрации.
        Полиморфизм достигается за счет обработки объектов различных типов
    через общий интерфейс. Это способствует универсальности кода, позволяя 
    использовать одну и ту же функциональность для разных типов.
        Абстрация в интерфейсах же реализуется через представление общего контракта,
    который создает унифицированный способ взаимодействия с различными обьектами
    без необходимости знания их конкретной реализации.

3. Mutex - предосталвяет механизм блокировки, при котором только одна
    горутина может получить доступ к общим данным. Другие горутины 
    будут заблокированы пока текущая  не разблокирует доступ к общим данным.
   RWMutex - Тот же мьютекс, но различия между блокировкой данных для чтения
    или записи данных. Несколько потоков может одновременно держать блокировку 
    для чтения, но только одна горутина может держать блокировку для записи.
    То есть, несколько горутин может выполнять операции чтения, не блокируя друг 
    друга и только одна горутина имеет доступ к записи, гарантируя, что в момент записи
    другие горутины не могут читать или писать данные.

4. Различия в том, как каналы обрабатывают передачу данных. В буфферизированных 
    каналах отправка данных ('chan <- qwerty') не блокируется, пока буфер не заполнится и
    прием ('data <- chan') не блокируется, пока буфер не опустеет, что позволяет
    отправлять и принимать данные ассинхронно, без блокировки в том случае, если другая
    сторона не готова принимать или отправлять данные.
    Не буфферизированный канал наборот, блокируется пока не найдется горутина,
    которая готова принять или отправить данные. Это обеспечивает точную синхронизацию
    между горутинами:  отправитель и получатель должны быть готовы одновременно к обмену данными.
5. 0 байт, так как она не имеет полей

6. Нет

7. В мапах порядок вывода элементов не гарантируется в одном порядке.

8. make используется для создания слайсов, мап и каналов и возвращает инициализированный
    экземпляр соотвествующего типа(указатель на слайс, мапу или канал)
   New в свою очередь используется только для выделения памяти для нового
    обьекта и возвращает указатель нулевое значение указанного типа(0 для инта и "" для строки).

9. Slice :
        1. var weight []int
        2. weight := []int{}
        3. weight := []int{20, 25, 23, 54}
        4. weight := make([]int, 4)
   Map :
        1. var data map[string]int
        2. data := make(map[string]int)
        3. data := make(map[string]int, 5)
        4. data := new(map[string]int)
        5. data := map[string]int{"legs": 2, "hands": 2, "head": 1}

10.  Вывод будет : 1 1. Функция update не изменяет значение p, так как
        область видимости у update и main разная, и значение 2, которое
        устанавливается в функции update вействительно только в ней,
        при возврате в main - переменная p будет снова ссылаться на а 
        с значением 1.

11.  Deadlock выведет. В анонимную функцию передается wg по значению,
        при вызове wg.Done() значение счетчика декрементируется только в 
        области видимости анонимной функции, но при выходе из нее - wg.Wait() 
        будет будет бесконечно ожидать декрементации. 

12.  Вывод будет : 0. Примерно такая проблема, консрукция if создает новый скоуп,
        в котором происходит определение новой для этого скоупа переменной n, ее
        инкрементация затрагивает только локальную для блока if переменную n,
        в свою очередь n из области видимости main не изменяет своего значния.

13. Вывод будет : [100 2 3 4 5]. В функции someAction `v[0] = 100` изменяет значение
        первого элемента среза a на значение 100. Далее, `v = append(v, b)` создает 
        новый слайс из всех элементов слайса а и добавляет в конец значение b(6).
        Но это никак не влияет на срез а, не считая только изменение первого элемента на 100.
        Новый срез v остается в локальном скоупе функции someAction. 

14. Вывод будет : [b b a][a a] . Анонимной функции в качестве параметров передается 
        слайс, он копируется, и все дальнейшие инструкции связаны только с локальным слайсом.
        Меняя слайс в этой функции мы не меняем слайс, который мы задали в main.
